---
layout: post
permalink: /:categories/:title.html
title: 碰撞检测之OBB
published: true
categories: math
tags: math collide
---

前言
===
在[简单几何图形的碰撞检测]({{ site.baseUrl }}/math/collide)里提到了几种几何图形的碰撞，但还不够完全，这篇文
章再补充一个---旋转矩形的碰撞(OBB)。

概念
===
---
> [维基包围盒参考知识](https://zh.wikipedia.org/wiki/%E5%8C%85%E5%9B%B4%E4%BD%93)    
> AABB盒：各边平行于坐标轴的包围盒    
> OBB盒: 任意方向的包围盒

---
> [维基向量参考知识](https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F)    
> 点积：A,B为任意向量,，```公式一：A·B=|A|*|B|cosθ```,A在B上的投影为|A|cosθ，当B为单位向量时，
A·B=|A|*|B|cosθ = |A|cosθ，A·B等于A在单位向量B上的投影。

---

定理
===

> SAT(Separating Axis Theorem),If two convex objects are not penetrating, there exists an axis for 
which the projection of the objects will not overlap.[证明传送门](http://www.dyn4j.org/2010/01/sat/#sat-intro)


> 分离轴定理：如果两个凸多边形不相交，那么一定存在一条轴，使它们在这条轴上的投影不重叠。

如何确定是否存在这条轴?
===

> 只需要判断凸多边形的每条边的法向量。如果在所有法向量上的投影相交，则不存这条轴，否则凸多边形不相交。


如何判断投影是否相交?
===

![投影图]({{ site.baseUrl }}/images/math/obb.jpg)    
图片中的红线是矩形在轴上的投影，长度为L1,L2,黑色是两个矩形中心在轴上的投影,L3。黑色线段的两个端点必然在两条红色
线段的中间。所以，(L1 + L2) < L3 时，投影不重叠，否则重叠。

上面的方法只适用于中心点必然在投影的中间。更通用的方法是:    

> 对多边形所有的顶点进行投影，记录最大值和最小值。

第一种方法dot次数是5，第二种方法dot次数是8。

实现代码
===

主要分四个步骤    

1\. 获得四个需要判断的轴
{% codeblock lua %}
-- @description 获得四条轴
local function getAxes(rect1,rect2)
    local axes = {}
    local width = rect1.width
    local height = rect1.height
    local angle = math.rad(rect1.angle)
    axes[1] = {x = width * math.cos(angle), y = width * math.sin(angle)}
    axes[2] = {x = height * math.cos(angle + math.pi / 2), 
                y = height * math.sin(angle + math.pi / 2)}
    width, height, angle = rect2.width, rect2.height, math.rad(rect2.angle)
    axes[3] = {x = width * math.cos(angle), y = width * math.sin(angle)}
    axes[4] = {x = height * math.cos(angle + math.pi / 2), 
                y = height * math.sin(angle + math.pi / 2)}
    return axes
end
{% endcodeblock %}
2\. 获得矩形的四个顶点
{% codeblock lua %}
--@description 获得矩形的四个顶点
local function getVerticals(rect)
    local verticals = {}
    local angle = math.rad(rect.angle)
    verticals[1] = {x = rect.x, y = rect.y}
    local deltaX1, deltaY1 = rect.width * math.cos(angle) , rect.width * math.sin(angle)
    local deltaX2, deltaY2 = rect.height * math.cos(angle + math.pi / 2) , 
                                rect.height * math.sin(angle + math.pi /2)
    verticals[2] = {x = rect.x + deltaX1, y = rect.y + deltaY1}
    verticals[3] = {x = rect.x + deltaX2, y = rect.y + deltaY2}
    verticals[4] = {x = rect.x + deltaX1 + deltaX2, y = rect.y + deltaY1 + deltaY2}
    return verticals 
end
{% endcodeblock %}
3\. 获得矩形在轴上的投影
{% codeblock lua %}
-- @description 获得点在轴上的投影，这是一个凸多边形通用求法
-- @return project project结构为{min = 1, max = 2}
local function getProject(ver,axis)
    local min, max = 1e99, -1e99
    for k,v in pairs(ver) do
        local num = dot(v,axis)
        min = math.min(num, min)
        max = math.max(num, max)
    end
    return {min = min, max = max}
end
{% endcodeblock %}
4\. 判断投影是否相交
{% codeblock lua %}
for k,axis in pairs(axes) do
    local proj1 = getProject(ver1, axis)
    local proj2 = getProject(ver2, axis)
    if proj1.min > proj2.max or proj1.max < proj2.min then
        return false
    end
end
{% endcodeblock %}

测试效果图
===
![测试用的gif]({{ site.baseUrl }}/images/math/obb.gif)

测试代码
===

{% codeblock lua %}

local MainScene = class("MainScene", cc.load("mvc").ViewBase)

--
-- @author ccy
-- @description OBB碰撞检测
-- @date 2016/4/3
--

-- @description 获得四条轴
local function getAxes(rect1,rect2)
    local axes = {}
    local width = rect1.width
    local height = rect1.height
    local angle = math.rad(rect1.angle)
    axes[1] = {x = width * math.cos(angle), y = width * math.sin(angle)}
    axes[2] = {x = height * math.cos(angle + math.pi / 2), 
                y = height * math.sin(angle + math.pi / 2)}
    width, height, angle = rect2.width, rect2.height, math.rad(rect2.angle)
    axes[3] = {x = width * math.cos(angle), y = width * math.sin(angle)}
    axes[4] = {x = height * math.cos(angle + math.pi / 2), 
                y = height * math.sin(angle + math.pi / 2)}
    return axes
end

--@description 获得矩形的四个顶点
local function getVerticals(rect)
    local verticals = {}
    local angle = math.rad(rect.angle)
    verticals[1] = {x = rect.x, y = rect.y}
    local deltaX1, deltaY1 = rect.width * math.cos(angle) , rect.width * math.sin(angle)
    local deltaX2, deltaY2 = rect.height * math.cos(angle + math.pi / 2) , 
                                rect.height * math.sin(angle + math.pi /2)
    verticals[2] = {x = rect.x + deltaX1, y = rect.y + deltaY1}
    verticals[3] = {x = rect.x + deltaX2, y = rect.y + deltaY2}
    verticals[4] = {x = rect.x + deltaX1 + deltaX2, y = rect.y + deltaY1 + deltaY2}
    return verticals 
end

-- @description 数量积
local function dot(vector1,vector2)
    return vector1.x * vector2.x + vector1.y * vector2.y
end

-- @description 获得点在轴上的投影，这是一个凸多边形通用求法
-- @return project project结构为{min = 1, max = 2}
local function getProject(ver,axis)
    local min, max = 1e99, -1e99
    for k,v in pairs(ver) do
        local num = dot(v,axis)
        min = math.min(num, min)
        max = math.max(num, max)
    end
    return {min = min, max = max}
end

-- @description obb碰撞检测
local function obbIntersectsObb(rect1,rect2)
    local axes = getAxes(rect1,rect2)
    local ver1 = getVerticals(rect1)
    local ver2 = getVerticals(rect2)
    for k,axis in pairs(axes) do
        local proj1 = getProject(ver1, axis)
        local proj2 = getProject(ver2, axis)
        if proj1.min > proj2.max or proj1.max < proj2.min then
            return false
        end
    end
    return true
end

function MainScene:onCreate()
    display.newSprite("MainSceneBg.jpg")
        :move(display.center)
        :addTo(self)
    local foreverRotation1 = cc.RepeatForever:create(cc.RotateBy:create(5,360))
    local foreverRotation2 = cc.RepeatForever:create(cc.RotateBy:create(3.5,-360))
    self.rect1 = cc.Sprite:create("rect.png")
        :addTo(self)
        :setAnchorPoint(cc.p(0,0))
        :setPosition(cc.p(500,300))
        :setRotation(30)
    self.rect1:runAction(foreverRotation1)
    self.rect2 = cc.Sprite:create("rect2.png")
        :addTo(self)
        :setPosition(cc.p(620,300))
        :setAnchorPoint(cc.p(0,0))
        :setRotation(-45)
        self.rect2:runAction(foreverRotation2)   
    local label = cc.Label:createWithSystemFont("是否碰撞: true", "Arial", 48)
        :align(display.CENTER, display.center)
        :addTo(self)
    local moveCallback = function(touch,event)
        local target = event:getCurrentTarget()
        local x,y   = target:getPosition()
        local delta = touch:getDelta()
        target:setPosition(x+delta.x,y+delta.y)      
    end
    addTouchListener(self.rect1,nil,moveCallback)
    addTouchListener(self.rect2,nil,moveCallback)
    self:scheduleUpdate(function()
        local x1,y1 = self.rect1:getPosition()
        local angle1 = self.rect1:getRotation()
        local x2,y2 = self.rect2:getPosition()
        local angle2 = self.rect2:getRotation()
        local rect1 = {x=x1,y=y1,width = 180, height = 72,angle = -angle1}
        local rect2 = {x=x2,y=y2,width = 180, height = 72,angle = -angle2}
        if obbIntersectsObb(rect2,rect1) then
            label:setString("是否碰撞: true")
        else
            label:setString("是否碰撞: false")
        end
    end)
end

return MainScene

{% endcodeblock %}

就是这样。