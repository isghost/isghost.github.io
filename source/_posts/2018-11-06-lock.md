---
layout: post
title: Java并发控制简介
published: true
categories:
tags:
date: 2018-11-06 00:00:00
---
# Java并发控制简介

## 锁

### 重入锁-ReentrantLock

#### 介绍

ReentrantLock与synchronized的性能差不多，主要ReentrantLock处理更加灵活。默认是非公平锁，拥有锁的线程，可以多次lock并且优化lock.

#### 非公平锁

```java
ReentrantLock reentrantLock = new ReentrantLock();
new Thread(()->{
    Try.run(() -> {
        reentrantLock.lock();
        System.out.println("lock1");
        Thread.sleep(200);
        reentrantLock.lock();
        System.out.println("lock2");
        Thread.sleep(200);
        reentrantLock.unlock();
        System.out.println("unlock1");
        Thread.sleep(200);
        reentrantLock.unlock();
        System.out.println("unlock2");
    });
}, "线程1").start();

new Thread(() -> {
    Try.run(() -> Thread.sleep(100));
    reentrantLock.lock();
    System.out.println("lock");
    reentrantLock.unlock();
    System.out.println("unlock");
},"线程2").start();
Try.run(() -> Thread.sleep(2000));
```

**输出结果**

```
lock1
lock2
unlock1
unlock2
lock
unlock
```

#### 公平锁

主要区别在于`lock`时

1. 如果锁已经被其他线程占用，公平锁会将线程直接放入链表队列， 而非公平锁会先进行抢占，如果不成功，再放入链表队列。
2. 无线程占用或者已拥有锁时，无区别

非公平锁效率高于公平锁， 主要原因是， 公平锁在等待队列有线程等待， 此时锁又可以占用时，会
1. 将当前线程加入等待队列， 变成阻塞状态
2. 将队列头部等待的线程转换成就绪状态，再到运行状态

CPU时间片调度，比较耗时，而非公平锁可以跳过这些步骤。

#### 常用方法

`tryLock（）`如果锁未被占用，则占用并返回true,否则返回false

`tryLock(long timeout, TimeUnit unit)`同`tryLock()`，额外等待一段时间

`lockInterruptibly（）`如果当前线程被中断，则释放锁

